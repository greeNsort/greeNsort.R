% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/greeNsort.R
\name{UVWoverhead}
\alias{UVWoverhead}
\title{String overhead}
\usage{
UVWoverhead(x, situation = c("insitu", "exsitu"), method = c("index"))
}
\arguments{
\item{x}{a character vector to be sorted}

\item{situation}{"insitu" will only allocate buffer memory and use the existing RAM for sorting, "exsitu" will allocate completely fresh RAM for data and buffer}

\item{method}{an attempt to classify the implementation,  "index" means the implementation rather indexes into arrays, "pointer" rather uses pointer arithmetic}
}
\value{
like \code{\link{rawperf}}
}
\description{
Function for measuring the overhead of the string pre- and postprocessing in the UVWsort functions
}
\details{
While the UVWsort functions measures the cost of sorting *wihtout* the overhead of counting string length and transforming R-string to C-strings and back,
`UVWoverhead` returns the timing of said overhead.
}
\examples{
x <- vtestdb$func$KafkaWords()
y <- x[]
p0 <- UVWoverhead(y)
p1 <- VKnuthsort(y)
p2 <- perfnow()
x <- sort(x)
p2 <- perfthen(p2, rowname="Rsort", size=1) # optimistic size
print(rbind(
  p0
, p1
, perfplus(p1, p0, rowname="Total")
, Test = perfminus(perfplus(p1, p0), p0, rowname="Test")
))
rbind(
  sperf(perfplus(p1, p0))
, sperf(p2)
)
}
\seealso{
\code{\link{UZacksort}} for indirect Zacksort using pointers to size-varying elements (strings, not stable),
\code{\link{WQuicksort2}} for indirect stabilized quicksort using pointers  to size-varying elements (strings, no ties by definition),
\code{\link{VKnuthsort}} for direct mergesort of size-varying elements (strings) using Knuth's merge with one loop check,
\code{\link{VFrogsort1}} for direct frogsort of size-varying elements (strings),
}
